
<div>
    <label class="ml-2">@Text</label>
</div>
<div class="form-group row">
    @if (imageDataUrls.Count() >= ImageQty)
    {
        <label class="ml-4">Si desea agregar imagenes debe quitar de las que ya estan</label>
    }
    else
    {
        <InputFile OnChange="OnInputFileChange" accept="image/*" capture class="form-control col-sm-4" />
    }

    @*<InputFile @onclick="Validate" OnChange="OnInputFileChange" accept="image/*" capture multiple />*@
    @*@onclick:preventDefault="preventDefault"*@
</div>
<br />

<div class="image-list col-md-5">
    <table class="table">
        <tbody>
            <tr>
                @{

                    int imageIndex = 0;
                    @foreach (var imageDataUrl in imageDataUrls)
                    {
                        var sendIndex = imageIndex;
                        <td width="50%">
                            <img src="@imageDataUrl" />
                            @*<button @onclick:preventDefault @onclick="@(() => OnQuitarImagen(sendIndex))">Quitar</button>*@
                            <ConfirmationDialog ButtonText="Quitar" objRef="sendIndex" OnOk="QuitarImagenByIndex2" Title="Confirmar Quitar Foto" ConfirmationMessage="Realmente desea quitar la foto" />
                        </td>
                        imageIndex++;
                    }
                }
            </tr>
        </tbody>
    </table>

</div>

@code {
    [Inject]
    IJSRuntime JsRuntime { get; set; }

    int imagelist = 0;
    JsInteropUtils JsInteropUtils { get; set; } = new JsInteropUtils();

    IList<string> imageDataUrls = new List<string>();
    [Parameter]
    public string MensajeLimiteImagenes { get; set; } = string.Empty;
    [Parameter]
    public string Text { get; set; } = string.Empty;
    [Parameter]
    public EventCallback<IList<string>> OnImageSet { get; set; }
    [Parameter]
    public int ImageQty { get; set; }

    protected async override Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        this.imageDataUrls = new List<string>();
    }
    async Task OnInputFileChange(InputFileChangeEventArgs e)
    {
        var imageFiles = e.GetMultipleFiles();
        if (imageFiles.Count >= ImageQty)
        {
            if (string.IsNullOrEmpty(MensajeLimiteImagenes))
            {
                MensajeLimiteImagenes = $"eligio {imageFiles.Count} imagenes, y solo se permiten {this.ImageQty}";
            }
            return;
        }
        var format = "image/png";
        foreach (var imageFile in imageFiles)
        {
            var resizedImageFile = await imageFile.RequestImageFileAsync(format, 100, 100);
            var buffer = new byte[resizedImageFile.Size];
            await resizedImageFile.OpenReadStream().ReadAsync(buffer);
            var imageDataUrl = $"data:{format};base64,{Convert.ToBase64String(buffer)}";
            imageDataUrls.Add(imageDataUrl);
        }
        await OnImageSet.InvokeAsync(imageDataUrls);
    }

    ConfirmBase DeleteConfirmation { get; set; }
    int SelectedImageToDelete = -1;
    async Task OnQuitarImagen(int imageIndex)
    {
        SelectedImageToDelete = imageIndex;
        // activar esta linea
        //DeleteConfirmation.Show();
        if (await JsInteropUtils.Confirm(JsRuntime, "Desea Borrar la imagen"))
        {
            imageDataUrls.RemoveAt(SelectedImageToDelete);
        }
    }

    void QuitarImagenByIndex(int imageIndex)
    {
        SelectedImageToDelete = imageIndex;

        imageDataUrls.RemoveAt(imageIndex);
    }
    void QuitarImagenByIndex2(object ob)
    {
        int imageIndex = (int)ob;
        imageDataUrls.RemoveAt(imageIndex);
    }
    void QuitarImagen(bool deleteConfirmed)
    {
        if (deleteConfirmed)
        {
            if (SelectedImageToDelete != -1)
            {
                imageDataUrls.RemoveAt(SelectedImageToDelete);
                SelectedImageToDelete = -1;
            }
        }
        SelectedImageToDelete = -1;

    }

}
